> [토비의 스프링](http://www.yes24.com/Product/Goods/7516911)을 읽고 정리한 내용입니다.  

# 1장: 오브젝트와 의존관계
- 스프링은 자바의 본질인 객체지향 프로그래밍이 가능하도록 하는 게 핵심 철학
- 스프링의 관심사는 **오브젝트**
    - 오브젝트를 어떻게 효과적으로 설계하고 구현하고, 이를 개선해나갈 것인가
- 리팩터링<sub>refactoring</sub>
    - 겉으로 드러나는 기능은 그대로지만 코드의 구조와 구현 방법을 변경해 더 나은 코드를 만든다!
    - 코드를 이해하기 편하게, 변화에는 효율적으로 대응할 수 있게
        - 이는 곧 생산성 증가, 코드 품질도 증가, 유지 보수에도 용이 
- 디자인 패턴
    - 소프트웨어 설계 시 특정 상황에서의 문제를 해결할 수 있는, **재사용 가능한 솔루션**을 뜻함
- 상속을 통한 확장
    - 상속 구조를 통해 **성격이 다른 관심사항을 분리**하고, **서로 독립적으로 변경/확장할 수 있도록**(영향을 덜 주도록) 해야 한다
    - 관련 디자인 패턴
        - 템플릿 메서드 패턴<sub>template method pattern</sub>
            - 슈퍼클래스에 기본적인 로직 흐름을 만들고, 기능 중 일부는 추상메서드 또는 오버라이딩 가능한 protected 메서드 등으로 만들어 서브 클래스에서 알맞게 구현하도록 하는 방법
        - 팩토리 메서드 패턴<sub>factory method pattern</sub>
            - 오브젝트 생성 방법을 슈퍼클래스에서 독립시키는 방법
    - 상속 구조의 문제점
        - 상하위 클래스가 밀접한 관계를 가짐
            - 서브클래스가 슈퍼클래스의 기능을 직접 사용 가능
        - 슈퍼클래스 내부에 변경이 발생하면, 모든 서브클래스는 영향을 받게됨
- 추상화
    - 어떤 것들의 공통적 성격을 뽑아 분리해내는 작업
    - 자바에서 추상화를 할 때 사용되는 가장 유용한 도구가 **인터페이스**
- 다형성
    - 코드에선 특정 클래스가 고정돼있지 않아도, 해당 클래스가 구현하고 있는 인터페이스를 코드에 넣어두었다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다
- 전략 패턴<sub>strategy pattern</sub>
    - 자신의 기능 맥락<sub>context</sub>에서, 필요에 따라 변경이 필요한 알고리즘은 인터페이스를 통해 통째로 외부로 분리, 그리고 이를 구현한 구체적 알고리즘 클래스를 필요에 따라 바꿔가며 사용할 수 있게 하는 패턴
    - 개방 폐쇄 원칙에 부합하는 패턴
    - 클라이언트는 컨텍스트를 사용하는데, 이때 컨텍스트가 사용할 전략을 클라이언트가 컨텍스트의 생성자를 통해 제공해주는 패턴
- 스프링은 객체지향적 설계 원칙과 디자인 패턴에 나타난 장점을 자연스럽게 개발자들이 활용할 수 있게 해주는 프레임워크
- 팩토리<sub>factory</sub>
    - (!= *디자인 패턴에서 말하는 '추상 팩토리 패턴'이나 '팩토리 메서드 패턴'*)
    - 객체의 생성 방법을 결정하고, 그렇게 만들어진 오브젝트를 반환해주는 역할
    - '오브젝트를 생성하는 쪽'과, '생성된 오브젝트를 사용하는 쪽'의 **역할과 책임을 분리**하기 위한 목적으로 사용됨
- 제어의 역전<sub>**IoC**; Inversion Of Control</sub>
    - 일반적인 프로그램 흐름은
        - `main()`과 같이 프로그램 시작점에서, 다음에 사용할 오브젝트를 결정하고, 결정한 오브젝트를 사용하고, 만들어진 오브젝트에 있는 메서드를 호출하고...
        - ==> 각 **오브젝트는** 프로그램 흐름을 결정하거나, 사용할 오브젝트를 구성하는 작업에 **능동적으로 참여**한다. 
        - 모든 종류의 작업을 **사용하는 쪽에서 제어**하는 구조!
    - 제어의 역전에서는
        - 오브젝트가, 자신이 사용할 오브젝트를 스스로 선택하지도, 생성하지도 않는다. 또 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없다.
        - **모든 제어 권한**을 **자신이 아닌 다른 대상에게 위임**하기 때문
        - 템플릿 메서드 패턴은 제어의 역전 개념을 활용해 문제를 해결하는 디자인 패턴!
            - e.g. 서브 클래스는 자신 안에 구현되어 있는 기능이 언제 사용될 지 모른다. 슈퍼 클래스에 정의된 템플릿 메서드가 자신이 필요할 때 서브 클래스에 구현된 기능을 사용함.
        - 프레임워크도 제어의 역전 개념이 적용된 대표적 기술
            - **프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야** 한다.
- 프레임워크와 라이브러리
    - 프레임워크
        - 애플리케이션 코드가 프레임워크에 의해 사용된다.
            - 보통 프레임워크 위에, 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드가 사용됨.
            - **애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작**
    - 라이브러리
        - 라이브러리를 사용하는 애플리케이션 코드는, 애플리케이션 흐름을 **직접 제어**한다.
            - 자신이 동작하는 중에 필요한 기능이 있다면 능동적으로 라이브러리를 사용한다.
- IoC는 프레임워크만의 기술도 아니고, 프레임워크가 꼭 필요한 개념도 아니다. 상당히 폭넓게 사용되는 프로그래밍 모델!
- IoC를 적용하면 설계가 깔끔해지고 유연성도 증가하고 확장성도 좋아진다.
- IoC에는 애플리케이션 컴포넌트의 생성, 관계 설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요
    - 이를 **프레임워크** 또는 **컨테이너**가 해줌
- **스프링**을 **IoC 프레임워크**라 하기도 한다.
    - 스프링은 IoC를 모든 기능의 기초가 되는 기반 기술로 삼고 있고, IoC를 극한까지 적용하고 있는 프레임워크다.
- 스프링의 핵심
    - bean 팩토리(`BeanFactory`), 애플리케이션 컨텍스트(`ApplicationContext`)
- `@Configuration`
    - '애플리케이션 컨텍스트/bean 팩토리' 가 사용할 설정 정보라는 표시
- `@Bean`
    - 오브젝트 생성을 담당하는 IoC용 메서드라는 표시
- 애플리케이션 컨텍스트를 사용하는 이유
    - 좀 더 범용적이고 유연한 방법으로 IoC 기능을 확장하기 위함
    - 클라이언트는 구체적인 팩토리 클래스를 알 필요 없음
        - XML처럼 단순한 방법을 사용해 애플리케이션 컨텍스트가 사용할 IoC 설정정보를 만들 수 있다
    - 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다
        - 애플리케이션 컨텍스트의 역할은 오브젝트 생성, 다른 오브젝트와의 관계설정 뿐 아니라 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고, 자동 생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 **오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공**
    - 애플리케이션 컨텍스트는 bean을 검색하는 다양한 방법을 제공한다
        - `getBean`으로 찾을 수도 있지만, 타입만으로도 검색할 수도 있고 애너테이션을 활용할 수도 있다
- IoC 용어
    - bean
        - 스프링이 IoC 방식으로 관리하는 오브젝트
        - **스프링이 직접 그 생성과 제어를 담당하는 오브젝트**만을 bean이라 부른다
    - bean 팩토리
        - BeanFactory는 **스프링 IoC를 담당하는 핵심 컨테이너**
        - bean을 등록, 생성, 조회, 반환하고 그 외 부가적으로 bean을 관리하는 기능을 담당
        - 보통은 이를 확장한 애플리케이션 컨텍스트를 이용
    - 애플리케이션 컨텍스트
        - 애플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당
        - ApplicationContext는 BeanFactory를 확장한 **IoC 컨테이너**
            - 즉 BeanFactory가 하는 역할 + 스프링이 제공하는 부가 서비스를 추가로 제공
        - **IoC 컨테이너**라 하기도 하고, **스프링 컨테이너**, BeanFactory라 부르기도 한다. 
    - 설정정보/설정 메타 정보 <sub>configuration metadata</sub>
        - **스프링 설정 정보**란 'ApplicationContext/BeanFactory'가 IoC를 적용하기 위해 사용하는 메타 정보
        - 컨테이너에 어떤 기능을 세팅하거나 조정하는 경우에도 사용되지만
        - IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용되는게 주 역할!
    - 컨테이너 또는 IoC 컨테이너
        - IoC 방식으로 bean을 관리한다는 의미에서 `ApplicationContext`나 `BeanFactory`를 **컨테이너** 또는 **IoC 컨테이너**라고도 한다
    - 스프링 프레임워크
        - 스프링이 제공하는 모든 기능을 통틀어 말할 때
- 오브젝트의 동일성과 동등성
    - 동일성<sub>identity</sub>
        - 완전히 동일한(identical) 오브젝트
        - `Object#equals()`는 동일성을 비교한다
        - 동일한 오브젝트는 동등하다
    - 동등성<sub>equality</sub>
        - 동일한 정보를 담고 있는(equivalent) 오브젝트
        - 동등한 오브젝트라고 해서 항상 동일한 것은 아니다
- 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리<sub>singleton registry</sub>
    - 스프링은 bean 오브젝트를 싱글톤으로 생성하는게 기본 설정이다.
- 왜 스프링은 싱글톤으로 bean을 만드는걸까?
    - 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문. 수많은 요청을 받아 처리할 것이므로, 요청 당 오브젝트를 새로 만들기보단 하나의 오브젝트를 공유해서 사용하는 게 효율적이기 때문        
- 싱글톤 패턴<sub>singleton pattern</sub>
    - 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 수(대게는 1개)만 존재하도록 강제하는 패턴
    - 애플리케이션 내에서 전역적으로 접근 가능하며, 단일 오브젝트로 존재하기 때문에 애플리케이션 여러 곳에서 공유하는 경우에 주로 사용  
- 싱글톤 패턴의 문제
    - 생성자가 private이기 때문에 상속할 수 없다
        - 싱글톤 패턴은 싱글톤 클래스 자기 자신만 오브젝트를 만들 수 있도록 하기 때문
        - 이는 객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다
    - 싱글톤은 테스트하기 힘들다
        - 싱글톤은 만들어지는 방식이 제한적이어서, 테스트에서 사용될 때 mock 오브젝트 등으로 대체하기 힘들다. 주입도 어려워서 만약 이 오브젝트가 필요하다면 직접 만드는 수밖에 없다.
    - 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다
        - 서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라, 싱글톤 클래스여도 하나 이상의 오브젝트가 만들어질 수 있다.
    - 싱글톤 사용은 전역 상태<sub>global state</sub>를 만든다
        - 싱글톤의 static 메서드를 통해 언제든 싱글톤에 접근할 수 있어, 애플리케이션 어디서든 사용될 수 있고 이는 전역 상태로 사용되기 쉽다. 
            - 전역 상태를 갖는다는 건, 아무 객체나 자유롭게 접근하고 수정/공유할 수 있다는 뜻. 그래서 객체지향 프로그래밍에선 권장되지 않는 프로그래밍 모델이다.
- 싱글톤 레지스트리<sub>singleton registry</sub>
    - 스프링은 서버 환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는걸 지지하지만, 자바의 기본적 싱글톤 패턴의 구현 방식에는 단점이 존재하여  
    스프링은 직접 **싱글톤 형태의 오브젝트를 만들고 관리하는 기능**을 제공한다. 이를 **싱글톤 레지스트리**라 한다.
- 싱글톤은 멀티 스레드 환경에선 여러 스레드가 동시에 접근하여 사용할 수 있으므로 **상태 관리**에 주의를 기울여야 한다.
    - 상태 정보를 내부에 갖고 있지 않는, 무상태<sub>stateless</sub>방식으로 만들어야 한다.
    - 만약 다른 싱글톤 bean을 저장하려고 한다면, 인스턴스 변수에 저장해도 괜찮다
        - 스프링이 한 번 초기화하고 나면 이후엔 수정되지 않기 때문에, 멀티스레드 환경에서 사용해도 문제가 없기 때문
    - 만약 읽기 전용값이라면 `static final`이나 `final`로 선언하기
- bean 스코프
    - 스프링이 관리하는 bean의 생성/존재/적용 범위
    - 스프링 bean의 기본 scope는 싱글톤
        - 컨테이너에 한 개의 오브젝트만 만들어지고, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안엔 계속 살아있음
    - 다른 스코프로는 프로토타입<sub>prototype</sub>, request, session 등이 있음 (관련내용은 10장에서 계속)
- 의존관계 주입; DI<sub>dependency injection</sub>
    - **스프링이 제공하는 IoC 방식의 핵심**
    - **스프링 IoC 기능의 대표적 동작 원리**
        - **스프링이 여타 프레임워크와 차별화되어 제공해주는 기능**이 **의존관계 주입**인 것이다
    - 오브젝트 레퍼런스를 외부로부터 제공(주입)받아, 이를 통해 여타 오브젝트와 다이나믹하게 의존관계가 만들어지는 것이 핵심
- 의존관계
    - 'A가 B에 의존하고 있다' == B가 변하면, 그 영향이 A에게 미친다는 뜻
        - B의 기능이 추가/변경되거나 형식이 바뀌거나 하면 그 영향은 A로 전달된다.
    - 하지만 B는 A의 변화에 영향을 받지 않는다
- 인터페이스에 대해서만 의존관계를 만들어두면, 인터페이스 구현 클래스와의 관계는 느슨해지고 변화에 영향을 덜 받는 상태가 된다
    - == **결합도가 낮아짐**
    - 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워짐
- 의존관계 주입은 아래 조건을 충족해야 한다.
    - 클래스 모델이나 코드에는 '런타임 시점의 의존관계'가 드러나지 않는다. 그러기 위해선 **인터페이스에만 의존**하고 있어야 한다.
        - 클라이언트는 구현 클래스의 존재를 몰라야 한다.
            - **설계 시점에는 알지 못했던** 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있다는 것
    - 런타임 시점의 의존관계는 컨테이너나 팩토리 등 **제 3의 존재가 결정**한다.
    - 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부(제 3의 존재)에서 제공(주입)해줌으로써 만들어진다.
- 스프링의 **애플리케이션 컨텍스트**, **bean 팩토리**, **IoC 컨테이너** 등이 모두, **외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌** 제 3의 존재다.
- 런타임 시점에 의존관계를 결정하고 만들어주는 제 3의 존재를, **의존관계 주입을 담당하는 컨테이너**! 줄여서 **DI 컨테이너**라 부를 수 있다.
- 스프링이 제공하는 IoC 방법
    - 의존관계 주입; DI<sub>dependency injection</sub>
        - 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 **외부로 넘기고**, **자신은 수동적으로 주입받은 오브젝트를 사용**
        - DI를 원하는 오브젝트는, 자기 자신도 컨테이너가 관리하는 bean이 되어야 한다.
    - 의존관계 검색; DL<sub>dependency lookup</sub>
        - 자신이 필요로하는 의존 오브젝트를 능동적으로 찾는 방법
        - 물론 '런타임 시 의존관계를 맺을 오브젝트를 결정하는 것' & '오브젝트의 생성 작업'은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 땐 <sub>메서드나 생성자를 통한 주입 대신</sub> 스스로 컨테이너에게 요청한다. 
        - e.g. 애플리케이션 컨텍스트의 `getBean`을 통해 오브젝트를 가져오고자 하는 것
        - 이 방법은 코드 안에 오브젝트 팩토리 클래스나 스프링 API가 사용되는 방법이다.
        - 검색하고자 하는 오브젝트 자신은, 스프링 bean일 필요가 없다
- DI 기술의 장점
    - 코드에는 런타임 클래스에 대한 의존관계가 나타나지 않음
    - 인터페이스를 사용하므로 결합도가 낮은 코드를 만듦
        - 이는 다른 책임을 가진, 사용 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않으며, 변경을 통한 다양한 확장 방법에 자유롭다.
    - 관심사의 분리<sub>separation of concerns; SoC</sub>를 통해 얻어지는 높은 응집도!
- 스프링은 DI를 편하게 사용할 수 있도록 도와주는 도구. 스프링 그 자체로 DI를 적극 활용한 프레임워크
- 스프링은 다양한 방법을 통해 DI 의존관계 설정정보를 만들 수 있다.
    - 자바 클래스를 이용
    - XML 이용

## 1장 정리
- 관심사의 분리, 리펙터링
    - 책임이 다른 코드를 분리하여 별도의 클래스로 만든다.
- 전략 패턴
    - 바뀔 수 있는 클래스는 인터페이스로 뽑아내고, 다른 클래스에서는 인터페이스를 통해서만 접근하도록 한다. 
    - 인터페이스를 정의한 쪽의 구현 방법이 달라져 클래스가 변경되더라도, 그 기능을 사용하는 클래스의 코드는 수정될 필요가 없도록 만든다. 
- 개방 폐쇄 원칙
    - 자신의 책임 자체가 변경되는 경우 외에는 불필요한 변화가 발생하지 않도록 막아주고, 자신이 사용하는 외부 오브젝트의 기능은 자유롭게 확장하거나 변경할 수 있게 만든다.
- 낮은 결합도, 높은 응집력
    - 한쪽의 기능 변화가 다른 쪽의 변경까지 초래하지 않게 결합도를 낮추고
    - 자신의 책임과 관심사에만 순수하게 집중하는 높은 응집력으로 깔끔한 코드를 만든다.
- IoC
    - 오브젝트가 생성되고 여타 오브젝트와의 관계를 맺는 작업의 제어권을, IoC 컨테이너로 넘겨  
    - 오브젝트 자신이 사용할 대상의 생성이나 선택에 관한 책임으로부터 자유롭게 만든다.
- 싱글톤 레지스트리
    - 서버에서 사용되는 오브젝트로서의 장점을 살릴 수 있는 싱글톤을 사용하면서,   
    싱글톤 패턴의 단점을 극복할 수 있게 설계된 컨테이너를 싱글톤 레지스트리라 한다.
- DI
    - 설계 시점과 코드에는 클래스와 인터페이스 사이의 느슨한 의존관계만 만들어 놓고
    - 런타임 시점에 실제 사용할 구체적 의존 오브젝트를 제 3자(DI 컨테이너)의 도움으로 주입받아, 다이나믹한 의존관계를 갖도록 해준다.  
- 생성자 주입, 수정자(setter) 주입
    - 의존 오브젝트를 주입할 때 생성자를 이용하는 방법과 수정자 메서드를 이용하는 방법이 있다.
- XML 설정
    - XML을 이용해 DI 설정정보를 만드는 방법도 있다.

<br/>
<br/>

---

<br/>
<br/>

# 2장: 테스트
- 스프링이 개발자에게 제공하는 가장 중요한 가치는
    - 객체지향
        - 복잡한 애플리케이션을 개발하는데 객체지향 기술을 이용해 효과적으로 개발할 수 있도록 도와준다.
    - 테스트
- 테스트
    - 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지 확인하고, 만든 코드를 확신할 수 있게 해주는 작업
- 단위 테스트<sub>unit test</sub>
    - 테스트하고자 하는 대상에 집중할 수 있다
    - 단위 테스트를 하는 이유는 빠르게 효율적으로 확인하기 위함이다.
- 테스트 에러
    - 테스트가 진행되는 동안 에러가 발생한 경우
- 테스트 실패
    - 에러 발생은 아니지만, 테스트 결과가 기대와 다르게 나오는 경우 
- 테스트는 다음과 같은 상황에서 개발자가 마음 편하게 잠들 수 있게 해주는 장치이다
    - 지저분한 코드를 문제없이 정리했기를
    - 새로운 기능을 문제없이 추가했기를
    - 어떤 오류를 수정하면서 또 다른 오류가 발생하진 않는지 확인하려고    
- JUnit과 같은 테스팅 프레임워크는
    - 특정 패턴을 가진 테스트를 만들 수 있고
    - 많은 테스트를 간단히 실행시킬 수 있고
    - 테스트 결과를 종합해서 볼 수 있고
    - 테스트가 실패한 곳을 빠르게 찾을 수 있다 
- JUnit 프레임워크가 요구하는 조건
    - 메서드에 `@Test` 애너테이션을 붙여야 하고
    - 해당 메서드는 public으로 선언하자
        - 전통적으로 JUnit은 public 메서드만을 테스트 메서드로 허용하기 때문
- 테스트 결과에 대한 검증은 JUnit이 제공해 주는 `assertThat`과 같은 static 메서드를 이용하면 된다
- 단위 테스트는 매번 실행할 때마다 동일한 테스트 결과를 얻을 수 있어야 한다 == 일관성 있는 결과가 보장돼야 한다
    - DB와 같은 외부 환경에 영향받지 않아야 하고
    - 모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과가 보장되어야 한다
- 테스트를 안 만드는 것도 위험하지만, 
    - 성의 없는 테스트를 만들어서, 문제가 있는 코드인데도 테스트가 성공해버리는 건 더 위험하다
    - 한 가지 결과만 검증하고 마는 것도 위험하다
- 테스트 메서드는 한 번에 한 가지 검증 목적에 충실해야 한다
- 테스트를 작성할 땐 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다
- 다양한 상황과 입력 값을 고려하는 포괄적인 테스트를 만들자
