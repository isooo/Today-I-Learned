> [토비의 스프링](http://www.yes24.com/Product/Goods/7516911)을 읽고 정리한 내용입니다.  

# 1장: 오브젝트와 의존관계
- 스프링은 자바의 본질인 객체지향 프로그래밍이 가능하도록 하는 게 핵심 철학
- 스프링의 관심사는 **오브젝트**
    - 오브젝트를 어떻게 효과적으로 설계하고 구현하고, 이를 개선해나갈 것인가
- 리팩터링<sub>refactoring</sub>
    - 겉으로 드러나는 기능은 그대로지만 코드의 구조와 구현 방법을 변경해 더 나은 코드를 만든다!
    - 코드를 이해하기 편하게, 변화에는 효율적으로 대응할 수 있게
        - 이는 곧 생산성 증가, 코드 품질도 증가, 유지 보수에도 용이 
- 디자인 패턴
    - 소프트웨어 설계 시 특정 상황에서의 문제를 해결할 수 있는, **재사용 가능한 솔루션**을 뜻함
- 상속을 통한 확장
    - 상속 구조를 통해 **성격이 다른 관심사항을 분리**하고, **서로 독립적으로 변경/확장할 수 있도록**(영향을 덜 주도록) 해야 한다
    - 관련 디자인 패턴
        - 템플릿 메서드 패턴<sub>template method pattern</sub>
            - 슈퍼클래스에 기본적인 로직 흐름을 만들고, 기능 중 일부는 추상메서드 또는 오버라이딩 가능한 protected 메서드 등으로 만들어 서브 클래스에서 알맞게 구현하도록 하는 방법
        - 팩토리 메서드 패턴<sub>factory method pattern</sub>
            - 오브젝트 생성 방법을 슈퍼클래스에서 독립시키는 방법
    - 상속 구조의 문제점
        - 상하위 클래스가 밀접한 관계를 가짐
            - 서브클래스가 슈퍼클래스의 기능을 직접 사용 가능
        - 슈퍼클래스 내부에 변경이 발생하면, 모든 서브클래스는 영향을 받게됨
- 추상화
    - 어떤 것들의 공통적 성격을 뽑아 분리해내는 작업
    - 자바에서 추상화를 할 때 사용되는 가장 유용한 도구가 **인터페이스**
- 다형성
    - 코드에선 특정 클래스가 고정돼있지 않아도, 해당 클래스가 구현하고 있는 인터페이스를 코드에 넣어두었다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다
- 전략 패턴<sub>strategy pattern</sub>
    - 자신의 기능 맥락<sub>context</sub>에서, 필요에 따라 변경이 필요한 알고리즘은 인터페이스를 통해 통째로 외부로 분리, 그리고 이를 구현한 구체적 알고리즘 클래스를 필요에 따라 바꿔가며 사용할 수 있게 하는 패턴
    - 개방 폐쇄 원칙에 부합하는 패턴
    - 클라이언트는 컨텍스트를 사용하는데, 이때 컨텍스트가 사용할 전략을 클라이언트가 컨텍스트의 생성자를 통해 제공해주는 패턴
- 스프링은 객체지향적 설계 원칙과 디자인 패턴에 나타난 장점을 자연스럽게 개발자들이 활용할 수 있게 해주는 프레임워크
- 팩토리<sub>factory</sub>
    - (!= *디자인 패턴에서 말하는 '추상 팩토리 패턴'이나 '팩토리 메서드 패턴'*)
    - 객체의 생성 방법을 결정하고, 그렇게 만들어진 오브젝트를 반환해주는 역할
    - '오브젝트를 생성하는 쪽'과, '생성된 오브젝트를 사용하는 쪽'의 **역할과 책임을 분리**하기 위한 목적으로 사용됨
- 제어의 역전<sub>**IoC**; Inversion Of Control</sub>
    - 일반적인 프로그램 흐름은
        - `main()`과 같이 프로그램 시작점에서, 다음에 사용할 오브젝트를 결정하고, 결정한 오브젝트를 사용하고, 만들어진 오브젝트에 있는 메서드를 호출하고...
        - ==> 각 **오브젝트는** 프로그램 흐름을 결정하거나, 사용할 오브젝트를 구성하는 작업에 **능동적으로 참여**한다. 
        - 모든 종류의 작업을 **사용하는 쪽에서 제어**하는 구조!
    - 제어의 역전에서는
        - 오브젝트가, 자신이 사용할 오브젝트를 스스로 선택하지도, 생성하지도 않는다. 또 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없다.
        - **모든 제어 권한**을 **자신이 아닌 다른 대상에게 위임**하기 때문
        - 템플릿 메서드 패턴은 제어의 역전 개념을 활용해 문제를 해결하는 디자인 패턴!
            - e.g. 서브 클래스는 자신 안에 구현되어 있는 기능이 언제 사용될 지 모른다. 슈퍼 클래스에 정의된 템플릿 메서드가 자신이 필요할 때 서브 클래스에 구현된 기능을 사용함.
        - 프레임워크도 제어의 역전 개념이 적용된 대표적 기술
            - **프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야** 한다.
- 프레임워크와 라이브러리
    - 프레임워크
        - 애플리케이션 코드가 프레임워크에 의해 사용된다.
            - 보통 프레임워크 위에, 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드가 사용됨.
            - **애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작**
    - 라이브러리
        - 라이브러리를 사용하는 애플리케이션 코드는, 애플리케이션 흐름을 **직접 제어**한다.
            - 자신이 동작하는 중에 필요한 기능이 있다면 능동적으로 라이브러리를 사용한다.
- IoC는 프레임워크만의 기술도 아니고, 프레임워크가 꼭 필요한 개념도 아니다. 상당히 폭넓게 사용되는 프로그래밍 모델!
- IoC를 적용하면 설계가 깔끔해지고 유연성도 증가하고 확장성도 좋아진다.
- IoC에는 애플리케이션 컴포넌트의 생성, 관계 설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요
    - 이를 **프레임워크** 또는 **컨테이너**가 해줌
- **스프링**을 **IoC 프레임워크**라 하기도 한다.
    - 스프링은 IoC를 모든 기능의 기초가 되는 기반 기술로 삼고 있고, IoC를 극한까지 적용하고 있는 프레임워크다.
- 스프링의 핵심
    - bean 팩토리(`BeanFactory`), 애플리케이션 컨텍스트(`ApplicationContext`)
- `@Configuration`
    - '애플리케이션 컨텍스트/bean 팩토리' 가 사용할 설정 정보라는 표시
- `@Bean`
    - 오브젝트 생성을 담당하는 IoC용 메서드라는 표시
- 애플리케이션 컨텍스트를 사용하는 이유
    - 좀 더 범용적이고 유연한 방법으로 IoC 기능을 확장하기 위함
    - 클라이언트는 구체적인 팩토리 클래스를 알 필요 없음
        - XML처럼 단순한 방법을 사용해 애플리케이션 컨텍스트가 사용할 IoC 설정정보를 만들 수 있다
    - 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다
        - 애플리케이션 컨텍스트의 역할은 오브젝트 생성, 다른 오브젝트와의 관계설정 뿐 아니라 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고, 자동 생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 **오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공**
    - 애플리케이션 컨텍스트는 bean을 검색하는 다양한 방법을 제공한다
        - `getBean`으로 찾을 수도 있지만, 타입만으로도 검색할 수도 있고 애너테이션을 활용할 수도 있다
- IoC 용어
    - bean
        - 스프링이 IoC 방식으로 관리하는 오브젝트
        - **스프링이 직접 그 생성과 제어를 담당하는 오브젝트**만을 bean이라 부른다
    - bean 팩토리
        - BeanFactory는 **스프링 IoC를 담당하는 핵심 컨테이너**
        - bean을 등록, 생성, 조회, 반환하고 그 외 부가적으로 bean을 관리하는 기능을 담당
        - 보통은 이를 확장한 애플리케이션 컨텍스트를 이용
    - 애플리케이션 컨텍스트
        - 애플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당
        - ApplicationContext는 BeanFactory를 확장한 **IoC 컨테이너**
            - 즉 BeanFactory가 하는 역할 + 스프링이 제공하는 부가 서비스를 추가로 제공
        - **IoC 컨테이너**라 하기도 하고, **스프링 컨테이너**, BeanFactory라 부르기도 한다. 
    - 설정정보/설정 메타 정보 <sub>configuration metadata</sub>
        - **스프링 설정 정보**란 'ApplicationContext/BeanFactory'가 IoC를 적용하기 위해 사용하는 메타 정보
        - 컨테이너에 어떤 기능을 세팅하거나 조정하는 경우에도 사용되지만
        - IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용되는게 주 역할!
    - 컨테이너 또는 IoC 컨테이너
        - IoC 방식으로 bean을 관리한다는 의미에서 `ApplicationContext`나 `BeanFactory`를 **컨테이너** 또는 **IoC 컨테이너**라고도 한다
    - 스프링 프레임워크
        - 스프링이 제공하는 모든 기능을 통틀어 말할 때
- 오브젝트의 동일성과 동등성
    - 동일성<sub>identity</sub>
        - 완전히 동일한(identical) 오브젝트
        - `Object#equals()`는 동일성을 비교한다
        - 동일한 오브젝트는 동등하다
    - 동등성<sub>equality</sub>
        - 동일한 정보를 담고 있는(equivalent) 오브젝트
        - 동등한 오브젝트라고 해서 항상 동일한 것은 아니다
- 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리<sub>singleton registry</sub>
    - 스프링은 bean 오브젝트를 싱글톤으로 생성하는게 기본 설정이다.
- 왜 스프링은 싱글톤으로 bean을 만드는걸까?
    - 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문. 수많은 요청을 받아 처리할 것이므로, 요청 당 오브젝트를 새로 만들기보단 하나의 오브젝트를 공유해서 사용하는 게 효율적이기 때문        
- 싱글톤 패턴<sub>singleton pattern</sub>
    - 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 수(대게는 1개)만 존재하도록 강제하는 패턴
    - 애플리케이션 내에서 전역적으로 접근 가능하며, 단일 오브젝트로 존재하기 때문에 애플리케이션 여러 곳에서 공유하는 경우에 주로 사용  
- 싱글톤 패턴의 문제
    - 생성자가 private이기 때문에 상속할 수 없다
        - 싱글톤 패턴은 싱글톤 클래스 자기 자신만 오브젝트를 만들 수 있도록 하기 때문
        - 이는 객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다
    - 싱글톤은 테스트하기 힘들다
        - 싱글톤은 만들어지는 방식이 제한적이어서, 테스트에서 사용될 때 mock 오브젝트 등으로 대체하기 힘들다. 주입도 어려워서 만약 이 오브젝트가 필요하다면 직접 만드는 수밖에 없다.
    - 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다
        - 서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라, 싱글톤 클래스여도 하나 이상의 오브젝트가 만들어질 수 있다.
    - 싱글톤 사용은 전역 상태<sub>global state</sub>를 만든다
        - 싱글톤의 static 메서드를 통해 언제든 싱글톤에 접근할 수 있어, 애플리케이션 어디서든 사용될 수 있고 이는 전역 상태로 사용되기 쉽다. 
            - 전역 상태를 갖는다는 건, 아무 객체나 자유롭게 접근하고 수정/공유할 수 있다는 뜻. 그래서 객체지향 프로그래밍에선 권장되지 않는 프로그래밍 모델이다.
- 싱글톤 레지스트리<sub>singleton registry</sub>
    - 스프링은 서버 환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는걸 지지하지만, 자바의 기본적 싱글톤 패턴의 구현 방식에는 단점이 존재하여  
    스프링은 직접 **싱글톤 형태의 오브젝트를 만들고 관리하는 기능**을 제공한다. 이를 **싱글톤 레지스트리**라 한다.
- 싱글톤은 멀티 스레드 환경에선 여러 스레드가 동시에 접근하여 사용할 수 있으므로 **상태 관리**에 주의를 기울여야 한다.
    - 상태 정보를 내부에 갖고 있지 않는, 무상태<sub>stateless</sub>방식으로 만들어야 한다.
    - 만약 다른 싱글톤 bean을 저장하려고 한다면, 인스턴스 변수에 저장해도 괜찮다
        - 스프링이 한 번 초기화하고 나면 이후엔 수정되지 않기 때문에, 멀티스레드 환경에서 사용해도 문제가 없기 때문
    - 만약 읽기 전용값이라면 `static final`이나 `final`로 선언하기
- bean 스코프
    - 스프링이 관리하는 bean의 생성/존재/적용 범위
    - 스프링 bean의 기본 scope는 싱글톤
        - 컨테이너에 한 개의 오브젝트만 만들어지고, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안엔 계속 살아있음
    - 다른 스코프로는 프로토타입<sub>prototype</sub>, request, session 등이 있음 (관련내용은 10장에서 계속)
- 의존관계 주입; DI<sub>dependency injection</sub>
    - **스프링이 제공하는 IoC 방식의 핵심**
    - **스프링 IoC 기능의 대표적 동작 원리**
        - **스프링이 여타 프레임워크와 차별화되어 제공해주는 기능**이 **의존관계 주입**인 것이다
    - 오브젝트 레퍼런스를 외부로부터 제공(주입)받아, 이를 통해 여타 오브젝트와 다이나믹하게 의존관계가 만들어지는 것이 핵심
- 의존관계
    - 'A가 B에 의존하고 있다' == B가 변하면, 그 영향이 A에게 미친다는 뜻
        - B의 기능이 추가/변경되거나 형식이 바뀌거나 하면 그 영향은 A로 전달된다.
    - 하지만 B는 A의 변화에 영향을 받지 않는다
- 인터페이스에 대해서만 의존관계를 만들어두면, 인터페이스 구현 클래스와의 관계는 느슨해지고 변화에 영향을 덜 받는 상태가 된다
    - == **결합도가 낮아짐**
    - 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워짐
- 의존관계 주입은 아래 조건을 충족해야 한다.
    - 클래스 모델이나 코드에는 '런타임 시점의 의존관계'가 드러나지 않는다. 그러기 위해선 **인터페이스에만 의존**하고 있어야 한다.
        - 클라이언트는 구현 클래스의 존재를 몰라야 한다.
            - **설계 시점에는 알지 못했던** 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있다는 것
    - 런타임 시점의 의존관계는 컨테이너나 팩토리 등 **제 3의 존재가 결정**한다.
    - 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부(제 3의 존재)에서 제공(주입)해줌으로써 만들어진다.
- 스프링의 **애플리케이션 컨텍스트**, **bean 팩토리**, **IoC 컨테이너** 등이 모두, **외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌** 제 3의 존재다.
- 런타임 시점에 의존관계를 결정하고 만들어주는 제 3의 존재를, **의존관계 주입을 담당하는 컨테이너**! 줄여서 **DI 컨테이너**라 부를 수 있다.
- 스프링이 제공하는 IoC 방법
    - 의존관계 주입; DI<sub>dependency injection</sub>
        - 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 **외부로 넘기고**, **자신은 수동적으로 주입받은 오브젝트를 사용**
        - DI를 원하는 오브젝트는, 자기 자신도 컨테이너가 관리하는 bean이 되어야 한다.
    - 의존관계 검색; DL<sub>dependency lookup</sub>
        - 자신이 필요로하는 의존 오브젝트를 능동적으로 찾는 방법
        - 물론 '런타임 시 의존관계를 맺을 오브젝트를 결정하는 것' & '오브젝트의 생성 작업'은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 땐 <sub>메서드나 생성자를 통한 주입 대신</sub> 스스로 컨테이너에게 요청한다. 
        - e.g. 애플리케이션 컨텍스트의 `getBean`을 통해 오브젝트를 가져오고자 하는 것
        - 이 방법은 코드 안에 오브젝트 팩토리 클래스나 스프링 API가 사용되는 방법이다.
        - 검색하고자 하는 오브젝트 자신은, 스프링 bean일 필요가 없다
- DI 기술의 장점
    - 코드에는 런타임 클래스에 대한 의존관계가 나타나지 않음
    - 인터페이스를 사용하므로 결합도가 낮은 코드를 만듦
        - 이는 다른 책임을 가진, 사용 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않으며, 변경을 통한 다양한 확장 방법에 자유롭다.
    - 관심사의 분리<sub>separation of concerns; SoC</sub>를 통해 얻어지는 높은 응집도!
- 스프링은 DI를 편하게 사용할 수 있도록 도와주는 도구. 스프링 그 자체로 DI를 적극 활용한 프레임워크
- 스프링은 다양한 방법을 통해 DI 의존관계 설정정보를 만들 수 있다.
    - 자바 클래스를 이용
    - XML 이용

## 1장 정리
- 관심사의 분리, 리펙터링
    - 책임이 다른 코드를 분리하여 별도의 클래스로 만든다.
- 전략 패턴
    - 바뀔 수 있는 클래스는 인터페이스로 뽑아내고, 다른 클래스에서는 인터페이스를 통해서만 접근하도록 한다. 
    - 인터페이스를 정의한 쪽의 구현 방법이 달라져 클래스가 변경되더라도, 그 기능을 사용하는 클래스의 코드는 수정될 필요가 없도록 만든다. 
- 개방 폐쇄 원칙
    - 자신의 책임 자체가 변경되는 경우 외에는 불필요한 변화가 발생하지 않도록 막아주고, 자신이 사용하는 외부 오브젝트의 기능은 자유롭게 확장하거나 변경할 수 있게 만든다.
- 낮은 결합도, 높은 응집력
    - 한쪽의 기능 변화가 다른 쪽의 변경까지 초래하지 않게 결합도를 낮추고
    - 자신의 책임과 관심사에만 순수하게 집중하는 높은 응집력으로 깔끔한 코드를 만든다.
- IoC
    - 오브젝트가 생성되고 여타 오브젝트와의 관계를 맺는 작업의 제어권을, IoC 컨테이너로 넘겨  
    - 오브젝트 자신이 사용할 대상의 생성이나 선택에 관한 책임으로부터 자유롭게 만든다.
- 싱글톤 레지스트리
    - 서버에서 사용되는 오브젝트로서의 장점을 살릴 수 있는 싱글톤을 사용하면서,   
    싱글톤 패턴의 단점을 극복할 수 있게 설계된 컨테이너를 싱글톤 레지스트리라 한다.
- DI
    - 설계 시점과 코드에는 클래스와 인터페이스 사이의 느슨한 의존관계만 만들어 놓고
    - 런타임 시점에 실제 사용할 구체적 의존 오브젝트를 제 3자(DI 컨테이너)의 도움으로 주입받아, 다이나믹한 의존관계를 갖도록 해준다.  
- 생성자 주입, 수정자(setter) 주입
    - 의존 오브젝트를 주입할 때 생성자를 이용하는 방법과 수정자 메서드를 이용하는 방법이 있다.
- XML 설정
    - XML을 이용해 DI 설정정보를 만드는 방법도 있다.

<br/>
<br/>

---

<br/>
<br/>

# 2장: 테스트
- 스프링이 개발자에게 제공하는 가장 중요한 가치는
    - 객체지향
        - 복잡한 애플리케이션을 개발하는데 객체지향 기술을 이용해 효과적으로 개발할 수 있도록 도와준다.
    - 테스트
- 테스트
    - 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지 확인하고, 만든 코드를 확신할 수 있게 해주는 작업
- 단위 테스트<sub>unit test</sub>
    - 테스트하고자 하는 대상에 집중할 수 있다
    - 단위 테스트를 하는 이유는 빠르게 효율적으로 확인하기 위함이다.
- 테스트 에러
    - 테스트가 진행되는 동안 에러가 발생한 경우
- 테스트 실패
    - 에러 발생은 아니지만, 테스트 결과가 기대와 다르게 나오는 경우 
- 테스트는 다음과 같은 상황에서 개발자가 마음 편하게 잠들 수 있게 해주는 장치이다
    - 지저분한 코드를 문제없이 정리했기를
    - 새로운 기능을 문제없이 추가했기를
    - 어떤 오류를 수정하면서 또 다른 오류가 발생하진 않는지 확인하려고    
- JUnit과 같은 테스팅 프레임워크는
    - 특정 패턴을 가진 테스트를 만들 수 있고
    - 많은 테스트를 간단히 실행시킬 수 있고
    - 테스트 결과를 종합해서 볼 수 있고
    - 테스트가 실패한 곳을 빠르게 찾을 수 있다 
- JUnit 프레임워크가 요구하는 조건
    - 메서드에 `@Test` 애너테이션을 붙여야 하고
    - 해당 메서드는 public으로 선언하자
        - 전통적으로 JUnit은 public 메서드만을 테스트 메서드로 허용하기 때문
- 테스트 결과에 대한 검증은 JUnit이 제공해 주는 `assertThat`과 같은 static 메서드를 이용하면 된다
- 단위 테스트는 매번 실행할 때마다 동일한 테스트 결과를 얻을 수 있어야 한다 == 일관성 있는 결과가 보장돼야 한다
    - DB와 같은 외부 환경에 영향받지 않아야 하고
    - 모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과가 보장되어야 한다
- 테스트를 안 만드는 것도 위험하지만, 
    - 성의 없는 테스트를 만들어서, 문제가 있는 코드인데도 테스트가 성공해버리는 건 더 위험하다
    - 한 가지 결과만 검증하고 마는 것도 위험하다
- 테스트 메서드는 한 번에 한 가지 검증 목적에 충실해야 한다
- 테스트를 작성할 땐 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다
- 다양한 상황과 입력 값을 고려하는 포괄적인 테스트를 만들자
- 테스트 코드 내용
    - 조건 + 행위 + 결과
- 테스트 코드는 잘 작성된 하나의 기능 정의서 역할이 되기도
- 테스트 주도 개발 <sub>TDD, Test Driven Development</sub>
    - 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다
- 애플리케이션 코드 뿐만 아니라 테스트 코드도 리팩터링 대상이다
- JUnit은 각 테스트 메서드를 실행할 때마다 새로운 테스트 클래스 오브젝트를 생성한다. 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해 주기 위해!
    - e.g. 테스트 클래스 내에 `@Test`가 2개 있다면, 해당 메서드가 포함된 클래스는 총 2번 오브젝트로 만들어짐

## 2장 정리
- 테스트는 자동화돼야 하고, 빠르게 실행할 수 있어야 한다
- `main()`대신 JUnit과 같은 테스트 프레임워크를 이용한 테스트 작성이 더 편리하다
- 테스트 결과는 일관성 있어야 하며, 실행 순서에 따라 결과가 달라지면 안 된다
- 테스트는 포괄적으로 작성해야 한다
    - 충분한 검증을 하지 않은 테스트는 안 하느니만 못함
- 코드 작성과 테스트 수행의 간격은 짧을수록 효과적
- 테스트하기 쉬운 코드가 좋은 코드
- 테스트를 먼저 만들고 테스트를 성공시키기 위해 코드를 만들어가는 게 TDD
- 테스트 코드도 애플리케이션 코드처럼 적절한 리팩터링이 필요
- Junit에서 제공하는 애너테이션을 이용해 테스트 메서드들의 공통 준비/처리 작업 등을 처리할 수 있다
- 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다
- 동일 설정 파일을 사용한 테스트는, 하나의 애플리케이션 컨텍스트를 공유한다
- `@Autowired`를 사용하면 컨텍스트의 bean을 테스트 오브젝트에 DI 할 수 있다
- 학습 테스트, 버그 테스트 등을 이용해 보자

<br/>
<br/>

---

<br/>
<br/>

# 3장: 템플릿
- 개방 폐쇄 원칙<sub>OCP</sub>
    - 변화의 특성이 다른 부분을 구분해 주고, 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어줌
- 템플릿
    - 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을, 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜 효과적으로 활용할 수 있도록 하는 방법 
- 템플릿 메서드 패턴
    - 상속을 통해 기능을 확장
    - 변하지 않는 부분은 슈퍼 클래스에, 변하는 부분은 슈퍼 클래스 내 추상 메서드로 정의하고 이는 서브 클래스에서 오버라이드하여 사용하도록 함
    - 단점: 상속을 이용하기 때문에 유연성이 떨어짐
- 전략 패턴의 적용
    - 개방 폐쇄 원칙<sub>OCP</sub>을 잘 지키는 구조이면서, 템플릿 메서드 패턴보다 유연하고 확장성이 뛰어난 패턴
    - 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 패턴
- 전략 패턴 + 익명 내부 클래스 
    - 템플릿/콜백 패턴
    - 바뀌지 않는 일정한 패턴을 가진 작업 흐름 + 그중 일부분만 자주 바꿔서 사용해야 하는 경우

## 3장 정리
- JDBC와 같이 예외가 발생할 가능성이 있으며 공유 리소스의 반환이 필요한 코드는, 반드시 `try/catch/finally` 블록으로 관리해야 한다
- 일정 작업 흐름이 반복되고 + 그중 일부 기능만 바뀌는 코드가 존재한다면 전략 패턴을 적용한다
- 만약 동일 애플리케이션 내에서 여러 종류의 전략을 다이나믹하게 구성하고 사용해야 한다면, 컨텍스트를 이용하는 클라이언트 메서드에서 직접 전략을 정의하고 제공하게 만들자
    - 익명 내부 클래스를 이용
- 컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면, 클래스를 분리하여 공유되도록 하자
- 템플릿/콜백 패턴은 단일 전략 메서드를 갖는 전략 패턴이면서 + 익명 내부 클래스를 사용해 매번 전략을 새로 만들어 사용하고 + 컨텍스트 호출과 동시에 전략 DI를 수행하는 방식
- 콜백의 코드에도 일정 패턴이 반복된다면, 콜백을 템플릿에 넣고 재활용하자
- 템플릿은 한 번에 하나 이상의 콜백을 사용할 수도 있고, 하나의 콜백을 여러 번 호출할 수도 있다
- 템플릿/콜백을 설계할 땐, 템플릿과 콜백이 주고받는 정보에 관심을 가지자

<br/>
<br/>

---

<br/>
<br/>

# 4장: 예외
- catch 블럭으로 예외를 감싸놓고, 아무 처리도 하지 않는 것은, 실제 예외가 발생하는 것보다 훨씬 나쁘다
- 예외는 복구를 하거나 처리를 하자. 무책임하게 던지거나 무시하지 말자
- 예외의 종류
    - **Error**
        - `java.lang.Error` 클래스의 서브 클래스들
        - 주로 자바 VM에서 발생시키는 거라, 애플리케이션 코드에서 처리할 수 있는 상황이 아님
            - e.g. OOME, ThreadDeath 
        - 시스템 레벨에서 특별한 작업을 하는 게 아니라면, 애플리케이션에선 이 에러에 대한 처리를 신경 쓰지 않아도 됨
    - **Exception**
        - `java.lang.Exception` 클래스와 그 서브 클래스
        - 개발자가 만든 애플리케이션 코드 상에서 예외 상황 발생 시 사용됨
        - 종류
            - **checked exception**
                - Exception의 서브 클래스
                    - RuntimeException을 상속하지 않은 클래스들
                - 이 예외가 발생할 경우 **반드시 예외 처리를 하도록 강제**된다
                - 체크 예외가 발생할 메서드를 사용할 땐, catch문으로 감싸던지 아니면 throw하던지 둘 중 하나는 해야 함. 그렇지 않으면 컴파일 에러 발생  
            - **unchecked exception**
                - RuntimeException의 서브 클래스
                - 이 예외들은 명시적으로 예외 처리를 강제하지 않기 때문에 언체크예외라고 부른다
                - 이 예외는 catch문으로 잡거나 throw 해줘도 되고 안 해줘도 됨
                - 런타임 예외는 주로 **프로그램 상에 오류가 있을 때 발생하도록 의도된** 것들
- 예외 처리 방법
    - 예외 복구
        - 예외 상황을 파악하고, **문제를 해결하여 정상 상태로 만드는** 것
            - IOException 에러 메시지를 유저에게 그냥 던져버리는 건 예외 복구가 아님
        - 체크 예외는 어떤 식으로든 예외를 복구할 가능성이 있는 경우에 사용
            - API를 사용하는 개발자에게, 예외 상황이 발생할 수 있음을 인식하게 하고 + 이에 대한 적절한 처리를 요구하기 위해 강제되는 거
    - 예외 처리 회피
        - 예외 처리를 자신이 담당하지 않고, 자신을 호출한 쪽으로 던져버리는 것
        - throw를 이용해 던지거나, catch문으로 잡은 후 로그로 남기고 throw
        - catch로 잡아놓고 아무 처리를 하지 않는다면(e.g. 로깅만 하고 끝내는 등) 이는 예외 처리 회피가 아님. 
            - 예외 처리 회피는 반드시 다른 오브젝트/메서드에 **예외를 대신 처리하도록 던져야** 한다
        - 자신의 코드에서 발생한 예외를 그냥 던져버리는 건 무책임한 책임회피
            - 만약 템플릿/콜백 형태처럼 긴밀하게 역할 분담을 하고 있는 관계라면, 콜백 오브젝트에서는 자신이 사용되는 템플릿에게 throw할 수도 있음. 
        - 예외를 회피하는 건, 예외를 복구하는 것처럼 의도가 분명해야 한다. 템플릿/콜백처럼 긴밀한 관계에 있는 다른 오브젝트에게 예외 처리 책임을 분명하게 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루는 게 더 최선의 방법이라는 분명한 확신이 있어야 한다
    - 예외 전환<sub>exception translation</sub>
        - 예외를 복구해서 정상 상태로는 만들 수 없기 때문에, 예외를 메서드 밖으로 던져버리는 것. 이때 발생한 예외를 그대로 넘기는 게 아니라 **적절한 예외로 전환하여 던진다**는 게 특징
        - 목적
            - 내부에서 발생한 예외를 그대로 던지는 것이, 해당 예외 상황에 대한 적절한 의미를 부여하지 못하는 경우 -> **의미를 분명하게 해줄 수 있는 예외로 바꾸기 위함**
                - e.g. 사용자를 추가 시 동일 아이디의 사용자가 이미 존재한다면 SQLException이 발생할 것이다. 이를 좀 더 명확한 의미인 `DuplicateUserIdException`로 전환할 수 있다
            - 보통 전환하려는 예외에 원래 예외를 담는 중첩 예외<sub>nested exception</sub>로 만드는게 좋다. 중첩 예외에는 `getCause()`를 이용해 최초 발생 예외가 무엇이었는지 포함해주자.
            - 예외 처리를 강제하는 **체크 예외를**, 언체크예외인 **런타임 예외로 바꾸기 위함**
                - 복구가 불가능한 예외라면 해당 체크 예외를 런타임 예외로 포장해, 다른 계층의 메서드에서 불필요한 throw 선언이 들어가지 않도록 해줘야 한다
- 예외 처리 전략
    - 런타임 예외의 보편화
        - 자바 초기엔 복구할 가능성이 조금이라도 있다면 체크 예외로 만든다 생각했지만, 지금은 런타임 예외로 만들려는 경향이 있다
    - 예외는 알 수 있도록 만들자
        - 개발자가, 혹은 팀 내에서 이해할 수 있는 예외를 정리해두고, 이 런타임 예외로 감싸서 던진다면 개발자에게 좀 더 의미 있는 정보를 전달할 수 있다.
        - 필요하면 언제든 잡아서 처리할 수 있게 별도의 예외로 정의할 수 있지만, 필요 없다면 신경 쓰지 않아도 되게 런타임 예외로 만들어 주자
    - 애플리케이션 예외
        - 비즈니스적인 의미를 띤 예외를 던지도록 하자
- 예외 전환의 목적
    - 불필요한 try/catch 제거
    - 로우 레벨의 예외를 좀 더 의미 있고 추상화된 예외로 바꾸기 위함
- DB마다 SQL 뿐만 아니라 에러의 종류와 원인도 제각각
    - 각 DB 벤더 별로 각각 정의한 고유의 에러 코드를 사용하기 때문
    - 이때 `DataAccessException`을 사용하면 됨. 스프링에선 `DataAccessException`을 이용해 자바의 다양한 데이터 액세스 기술 사용 시 발생할 수 있는 예외를 추상화해두었다.

## 4장 정리
- 예외를 잡아서 아무런 조취를 취하지 않거나, 의미 없는 throws 선언을 남발하는 건 위험!
- 예외는 복구하거나, 예외 처리 오브젝트로 의도적으로 전달하거나, 적절한 예외로 전환해야 한다
- 예외 전환의 방식으로는 좀 더 의미 있는 예외로 변경하거나, 불필요한 catch/throws를 피하기 위해 런타임 예외로 포장하는 방법이 있다
- 복구할 수 없는 예외는 가능한 한 빨리 런타임 예외로 전환
- 애플리케이션 로직을 담기 위한 예외는 체크 예외로 만든다
- JDBC의 SQLException은 대부분 복구할 수 없는 예외이므로 런타임 예외로 포장해 주자
- SQLException의 에러 코드는 DB에 종속적이기 때문에 DB에 독립적인 예외로 전환해 주자
- 스프링은 `DataAccessException`을 통해 DB에 독립적으로 사용 가능한 추상화된 런타임 예외 계층을 제공한다
- DAO를 데이터 액세스 기술에서 독립시키려면, 인터페이스 도입하고 런타입 예외로 전환해 기술에 독립적인 추상화된 예외로 전환하는 것이 필요하다

<br/>
<br/>

---

<br/>
<br/>

# 5장: 서비스 추상화
- 스프링은 성격이 비슷한 여러 종류의 기술을 추상화하고, 이를 일관된 방법으로 사용할 수 있도록 지원한다 
- 데이터 액세스 로직이 바뀌었다고 해서 비즈니스 로직 코드를 수정하는 일은 없어야 한다
- 작성한 코드를 살펴볼 땐 아래 항목을 생각해보자
    - 중복 코드는 없는가
    - 코드가 어떤 일을 하는지 이해하기 쉬운가
    - 코드가 자신이 있어야 할 자리에 있는가
    - 앞으로 변경이 발생한다면 어떤 것이 있을 수 있고, 그 변경에 쉽게 대응할 수 있도록 작성되어 있는가
- 객체지향적 코드의 기본 원리는 **코드를 더 이해하기 쉽고 변화에 대응하기 편하게** 만드는 것
- 트랜잭션
    - 더 이상 나눌 수 없는 단위의 작업
    - 중간에 예외가 발생해서 작업을 완료할 수 없다면, 아예 작업이 시작되기 전 초기 상태로 돌려놓는 것
- 모든 트랜잭션은 시작 지점과 종료 지점이 있다
    - 시작 방법은 1가지
    - 종료 방법은 2가지
        - 롤백<sub>rollback</sub>
            - 모든 작업을 무효화
        - 커밋<sub>commit</sub>
            - 모든 작업을 확정
- JDBC의 트랜잭션은 '하나의 Connection을 가져와 사용 -> 닫음' 사이에 존재한다
- 트랜잭션의 시작/종료는 Connection 오브젝트를 통해 이뤄짐
    - 트랜잭션이 한 번 시작되면, `commit()` 혹은 `rollback()`이 호출될 때까지, 작업은 하나의 트랜잭션으로 묶인다
- 로컬 트랜잭션<sub>local transacion</sub>
    - 하나의 DB 커넥션 안에서 만들어지는 트랜잭션
- 트랜잭션 동기화<sub>transaction synchronization</sub>
    - 클래스에서 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고, 이후에 호출되는 DAO 의 메서드에서는 저장된 Connection 을 가져다가 사용하게 하는 것
- 글로벌 트랜잭션<sub>gloabl transaction</sub>
    - 별도의 트랜잭션 관리자를 통해 트랜잭션을 관리
    - 트랜잭션 매니저를 통해 여러 개의 DB가 참여하는 작업을 하나의 트랜잭션으로 묶을 수 있음
    - 자바에선 JDBC 외에, '글로벌 트랜잭션을 지원하는 트랜잭션 매니저'를 JTA<sub>java transaction api</sub>라는 API를 통해 제공
        - JTA를 이용해 트랜잭션 매니저를 활용하면, 여러 DB나 메시징 서버에 대한 작업을 하나의 트랜잭션으로 통합하는 분산 트랜잭션 or 글로벌 트랜잭션이 가능함
            - 관련 내용은 11장에서 계속... 하나 이상의 DB가 참여하는 트랜잭션을 만들려면 JTA를 사용해야 한다는 것만 일단 알아두자
- JDBC
    - 자바의 DB 프로그램 개발자는 JDBC덕분에 DB의 종류에 상관없이 일관된 방법으로 데이터 엑세스 코드를 작성할 수 있다. 
- 스프링은 트랜잭션 기술의 공통점을 담은 '트랜잭션 추상화 기술'을 제공한다.
    - `interface PlatformTransactionManager`
        - 스프링이 제공하는 트랜잭션 경계 설정을 위한 추상 인터페이스
        - e.g. 구현체로 `DataSourceTransactionManager`, `JpaTransactionManager`, `HibernateTransactionManager` 등이 있다
    - 구체적 트랜잭션 기술에 독립적인 코드를 만들 수 있다. 
- 서로에게 영향을 주지 않고 확장될 수 있는 구조를 만드는 게 스프링 DI가 추구하는 바
- 단일 책임 원칙<sub>SRP; single responsibility principle</sub>
    - 하나의 모듈은 한 가지 책임을 가져야 한다
    - 이 원칙을 잘 지키려면 인터페이스를 도입하고 DI로 이들을 연결하면 된다.
- 스프링을 DI 프레임워크라 부르는 이유
    - 외부 설정 정보를 통한 런타임 오브젝트 DI
    - 자바 엔터프라이즈 기술의 많은 문제를 해결하는데, DI에 담긴 원칙과 이를 응용하는 프로그래밍 모델을 적극적으로 활용하고 있기 때문
    - 깔끔하고 유연한 코드와 설계를 만들어 낼 수 있도록 도와줌
- 서비스 추상화
    - 제공하는 기능은 유사하지만, 사용 방법이 다른 다양한 로우 레벨 기술에 대해, 추상 인터페이스와 일관성 있는 접근 방법을 제공해 주는 것
- 테스트 대역<sub>test double</sub> 
    - 테스트 대상이 되는 오브젝트가 필요로 하는 기능을 충실하게 수행하면서, 빠르고 쉽게 테스트를 실행할 수 있도록 사용하는 오브젝트를 지칭
    - 종류
        - 스텁<sub>stub</sub>
            - 테스트 동안에 코드가 정상적으로 수행되게 돕는 역할
            - 테스트 코드 내부에서 간접적으로 사용됨
            - 의존 오브젝트를 테스트 스텁으로 변경하여 사용한다.
            - 스텁을 이용하면 간접적인 입력값을 지정해 줄 수도 있고, 간접적인 출력값도 받게 할 수 있다
            - 테스트가 수행할 수 있도록 의존 오브젝트에 간접적으로 입력값을 제공
        - 목<sub>mock</sub>
            - 테스트 대상 오브젝트와 의존 오브젝트 사이에 일어나는 일을 검증할 수 있도록 설계된 것
            - 스텁처럼 테스트 오브젝트가 정상적으로 실행될 수 있게 도와주면서, 테스트 오브젝트와 자신(mock)사이에 일어난 커뮤니케이션 내용을 저장해놨다가 테스트 결과를 검증할 때 활용할 수 있게 함
            - 간접적인 출력 값까지 확인 가능 

## 5정 정리
- 코드는 책임과 역할에 따라 분리되어야 한다
- DAO의 기술 변화에 서비스 계층의 코드가 영향을 받아서는 안된다. **인터페이스와 DI를 이용해 결합도를 낮춰**주자.   
- DAO를 사용하는 비즈니스 로직에는 단위 작업을 보장해 주는 트랜잭션이 필요
- 트랜잭션 경계 설정
    - 트랜잭션의 시작과 종료를 지정하는 일
    - 주로 비즈니스 로직 안에서 지정함
- 스프링은 트랜잭션 동기화 기법을 제공한다
- 비즈니스 로직을 담은 코드가 트랜잭션 방법에 따라 변경된다면 이는 OCP에 위반되며, DAO가 사용하는 특정 기술에 강결합하고 있는 형태가 된다
- 스프링이 제공하는 트랜잭션 서비스 추상화를 이용하면, 트랜잭션 경계 설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 만들 수 있다
- 서비스 추상화란 로우 레벨의 트랜잭션 기술과 API의 변화에 상관없이 일관된 API를 가진 추상화 계층을 도입한다.
- 테스트 대역은 테스트 대상 오브젝트가 원활히 동작할 수 있도록 도우면서 테스트를 위해 간접적인 정보를 제공하기도 한다
- 목 오브젝트란 테스트 대상으로부터 전달받은 정보를 검증할 수 있도록 설계된 오브젝트

<br/>
<br/>

---

<br/>
<br/>

# 6장: AOP
- 스프링 3대 기반 기술
    - IoC/DI
    - 서비스 추상화 
    - AOP
- 스프링에 적용된 가장 인기 있는 AOP 적용 대상은 선언적 트랜잭션
    - AOP를 통해 좀 더 깔끔한 트랜잭션 경계 설정 기능을 구현할 수 있다
- 단위 테스트
    - 외부 리소스를 사용하지 않도록 고립시켜 테스트하는 것
- 통합 테스트
    - 외부 리소스나 다른 오브젝트 등, 둘 이상의 단위가 결합하여 동작하며 테스트가 수행되는 경우
- Mockito 프레임워크
    - 목 오브젝트 방식을 지원하는 프레임워크
    - 간단한 메서드 호출만으로 다이나믹하게 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들어 줌
    - 인터페이스를 이용해 목 오브젝트를 만든다
    - 목 오브젝트가 리턴할 값이 있으면 이를 지정해 줄 수 있다
    - 특정 메서드가 호출되면 강제로 예외를 던지게 할 수도 있다
    - 목 오브젝트에 전달된 파라미터를 검증할 수도 있다 (ArgumentCaptor)
- 프록시<sub>proxy</sub>
    - 자신이 마치 클라이언트가 사용하려는 실제 대상인 것처럼 위장하여, 클라이언트의 요청을 받아주는 대리자(대리인)
    - 타깃과 동일한 인터페이스를 구현함
    - 프록시는 타깃을 제어할 수 있는 위치
- 타깃<sub>target</sub>, 실체<sub>real subject</sub>
    - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트
- 프록시 사용 목적
    - 클라이언트가 타깃에 접근하는 방법을 제어하기 위함
        - **프록시 패턴**
    - 타깃에 부가적인 기능을 부여하기 위함
        - **데코레이터 패턴**
- **데코레이터 패턴**
    - **런타임 시에 다이나믹하게 타깃에 부가적인 기능을 부여**하기 위해 프록시를 사용하는 패턴
        - ==> 코드 상에선 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해지지 않는다는 뜻
    - 데코레이터 패턴에선 프록시가 꼭 1개만 적용되는 건 아님. 여러 프록시(데코레이터)가 적용될 수도 있음
    - 프록시로서 동작하는 각 데코레이터는, 자신이 최종 타깃으로 위임하는지 아니면 또 다른 데코레이터 프록시에게 위임하는지 알 수 없음. 
        - 그래서 데코레이터 코드 내에서, 다음 위임 대상은 인터페이스로 선언하여 외부에서 런타임 시에 주입받을 수 있게 작성해야 한다
    - 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로, 새로운 기능을 추가할 때 유용한 패턴!

- **프록시 패턴**
    - 타깃에 대한 접근 방법을 제어하려는 목적으로 프록시를 사용하는 패턴
        - 디자인 패턴에서 말하는 프록시 패턴!
    - 타깃의 기능을 확장하거나 추가하지 않음. 대신 **클라이언트가 타깃에 접근하는 방식을 제어**
        - **타깃의 기능 자체에는 관여하지 않음**
    - 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 할 때, 실제 타깃 오브젝트를 만들지 않고 프록시를 넘겨줌. 그러고 나서 프록시의 메서드를 통해 타깃을 사용하려고 하면, 그때 프록시가 타깃 오브젝트를 생성하여 요청을 위임하는 방식
        - 꼭 필요한 시점까지 타깃 오브젝트를 생성하지 않음
    - 프록시 패턴의 프록시는, 코드에서 자신이 만들거나 접근할 타깃 클래스의 정보를 알고 있는 경우가 많다.
        - 생성을 지연하는 프록시라면, 타깃의 구체적 생성 방법을 알아야 하기 때문에!
    - 프록시 패턴의 프록시 역시 인터페이스를 통해 위임하는 구조를 가질 수 있다

> - 타깃과 동일한 인터페이스를 구현하고, 클라이언트와 타깃 사이에 존재하면서 기능의 '부가/접근 제어'를 담당하는 오브젝트를 프록시라 통칭할 수 있다

### 다이나믹 프록시
- 자바에는 `package java.lang.reflect`안에 프록시를 손쉽게 만들 수 있게 지원해 주는 클래스들이 있다
    - 프록시를 직접 만드는 건 사실 번거로운 일,,
    - 이 패키지 내 API를 이용해 프록시처럼 동작하는 오브젝트를 다이나믹하게 생성할 수 있다
        - `프록시 팩토리`에 의해 **런타임 시 다이나믹하게 만들어지는** 오브젝트!
- 다이나믹 프록시는 **리플렉션** 기능을 이용해 프록시를 만들어 준다
- 다이나믹 프록시 오브젝트는 타깃 인터페이스와 동일한 타입으로 만들어지기 때문에, 클라이언트는 다이나믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용한다
- 프록시 팩토리에게 구현 인터페이스에 대한 정보를 제공하면, 해당 인터페이스를 구현한 클래스의 오브젝트를 자동으로 만들어주기 때문에 프록시 클래스를 만들 때 인터페이스 내 메서드를 모두 구현해 줬던 수고로움을 덜 수 있다  
- 다이나믹 프록시는 인터페이스를 구현한 클래스의 오브젝트를 만들어주지만, 프록시로 필요한 부가 기능 코드는 직접 작성해 줘야 한다
    - 이때 부가 기능은 `java.lang.reflect.InvocationHandler`를 구현한 오브젝트에 담아준다
        - 다이나믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환하여 `InvocationHandler`의 구현 오브젝트의 `invoke()`로 넘긴다
- 다이나믹 프록시를 생성하려면
    ```java
    public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
    ```
    - `ClassLoader loader`
        - 다이나믹 프록시가 정의되어 있는 클래스 로더를 지정
    - `Class<?>[] interfaces`
        - 다이나믹 프록시가 구현할 인터페이스
        - 한 번에 하나 이상의 인터페이스 구현이 가능하여 배열로 받는다
    - `InvocationHandler h`
        - 부가 기능과 위임 관련 코드를 담고 있는 `InvocationHandler`의 구현체를 제공

### 팩토리 bean
- 스프링을 대신해 오브젝트의 생성을 맡아줄 특별한 bean
- `FactoryBean`
    ```java
    package org.springframework.beans.factory;

    public interface FactoryBean<T> {
        T getObject() throws Exception; // bean 오브젝트를 생성하여 반환
        Class<?> getObjectType();   // 생성되는 오브젝트의 타입을 알려줌
        default boolean isSingleton() { // getObject()로 생성된 오브젝트가, 싱글톤 오브젝트인지 알려줌
            return true;
        }
    }
    ```

### 프록시 팩토리 bean 방식의 장점과 한계
- 장점         
    - 다이나믹 프록시를 이용해 타깃 인터페이스를 일일이 구현하지 않아도 됨
    - 하나의 핸들러 메서드를 구현하여, 수많은 메서드에 부가 기능을 부여할 수 있게 됨
        - 코드 변경 없이 기존 코드에 부가 기능을 추가
- 한계
    - 한 번에 여러 클래스에 공통적인 기능을 제공하기 어려움
        - 거의 비슷한 프록시 팩토리 bean 설정이 중복될 수 있음.. 

### ProxyFactoryBean
- 스프링은 `ProxyFactoryBean`라는 '프록시 오브젝트를 생성해주는 기술'을 추상화한 팩토리 bean을 제공
    - 프록시를 생성하여 bean 오브젝트로 등록하게 해주는 
    - `ProxyFactoryBean`는 순수하게 프록시만 생성하고, 프록시를 통해 제공해줄 부가 기능은 별도 bean에 두는 구조를 만들 수 있음
        - 이때 부가 기능은 `MethodInterceptor`인터페이스를 구현하여 만들면 됨 
- `MethodInterceptor`
    - 타깃 오브젝트에 상관없이 독립적으로 만들 수 있음
    - 타깃이 다른, 여러 프록시에서 함께 사용할 수 있음
    - 싱글톤 bean으로 등록 가능

#### 어드바이스 <sub>advice</sub>
- 타깃 오브젝트에 종속되지 않는 순수한 **부가 기능을 담은** 오브젝트

#### 포인트컷 <sub>pointcut</sub>
- 부가 기능 적용 대상 **메서드 선정 방법**
   
> 함께 두기엔 성격이 다르고 변경 이유와 시점도 다르고, 생성 방식과 의존 관계가 다른 코드는 분리해주자.  


- 기존 JDK 다이나믹 프록시를 이용한 방식의 문제점은 부가 기능을 가진 `InvocationHandler`가 타깃과 메서드 선정 알고리즘 코드에 의존하고 있다는 것
    - 만약 타깃이 다르고 메서드 선정 방식이 다르다면, `InvocationHandler` 오브젝트는 여러 프록시가 공유할 수 없는 상황. 즉 bean으로 구성된 `InvocationHandler` 오브젝트는 결국 특정 타깃을 위한 프록시에 제한된다는 의미
    - 그럼 `InvocationHandler`를 bean으로 등록하지 않고, 팩토리 bean 내부에서 매번 생성하도록 한다면? 
        - 그럼 타깃 변경이나 메서드 선정 알고리즘 변경과 같은 확장이 필요할 시, 팩토리 bean 내의 프록시 생성 코드를 직접 변경해줘야하는 번거로움 발생   
            - ==> 결국 위 구조는 어떠한 경우에도 확장에 유연하지 못하고 관련 없는 코드까지 변경시키는, OCP 원칙을 위반하는 구조인 셈
- 스프링 ProxyFactoryBean을 이용한 구조는 '부가 기능'<sub>advice</sub>과 '메서드 선정 알고리즘'<sub>pointcut</sub>을 활용한 유연한 구조!
    - 2가지 확장 기능 모두 프록시에 DI로 주입돼서 사용됨
        - 둘 다 여러 프록시에서 공유가 가능하도록 만들어지기 때문에 싱글톤 bean으로 등록 가능!  
    ```java
    final ProxyFactoryBean pfBean = new ProxyFactoryBean();
    pfBean.setTarget(new HelloTarget());

    final NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();
    pointcut.setMappedName("sayH*"); // sayH 로 시작하는 모든 메서드에게 적용하겠다

    // pointcut과 advice를, Advisor로 묶어서 한 번에 추가!
    pfBean.addAdvisor(new DefaultPointcutAdvisor(pointcut, new UppercaseAdvice()));

    final Hello proxiedHello = (Hello) pfBean.getObject();
    ```            
    - 어드바이저 = 포인트컷(메서드 선정 알고리즘) + 어드바이스(부가 기능)

### 부가 기능의 모듈화
- 부가 기능을 모듈화 하면, 핵심 기능을 담은 코드와 설정에 영향을 주지 않는 깔끔한 형태를 만들 수 있게 해준다

### AOP<sub>aspect oriented programming</sub>: 애스펙트 지향 프로그래밍
- 애스펙트<sub>aspect</sub>
    - 그 자체로는 애플리케이션의 핵심 기능을 담고 있지는 않지만
    - 애플리케이션을 구성하는 중요 요소 중 하나이고
    - 핵심 기능에 부가되어 의미를 갖는 특별한 모듈
     
- 애스펙트 지향 프로그래밍
    - 애플리케이션의 핵심 기능에서, 부가 기능을 분리하여 애스펙트라는 모듈로 만들어 설계하고 개발하는 방법
    - AOP는 애스펙트를 분리함으로써 핵심 기능을 설계하고 구현할 때 객체지향적 가치를 지킬 수 있도록 도와줌
    - 애플리케이션을 특정 관점 기준으로 바라볼 수 있게 한다고 하여, 관점 지향 프로그래밍이라고도 함

### 프록시를 이용한 AOP
- 스프링 AOP는 자바의 기본 JDK와 스프링 컨테이너 외엔 특별한 기술이나 환경을 요구하지 않음. 독립적으로 개발한 부가 기능 모듈을, 다양한 타깃 오브젝트의 메서드에 다이나믹하게 적용해주기 위해, 가장 중요한 역할을 맡는게 **프록시**
    - 그래서 스프링 AOP는 프록시 방식의 AOP라고 함

### AspectJ의 바이트코드 생성과 조작을 통한 AOP
- AOP 프레임워크인 AspectJ는 프록시를 사용하지 않고 바이트 코드를 생성/조작하는 방식
    - 프록시처럼 간접적인 방법이 아닌, 타깃 오브젝트를 뜯어 고쳐 부가 기능을 직접 넣어주는 직접적 방법!
- 왜 AspectJ는 프록시가 아닌 '컴파일된 클래스 파일 수정'이나 '바이트코드 조작'같은 복잡한 방법을 택했을까?
    - 바이트코드를 조작해 타깃 오브젝트를 직접 수정하면, 스프링같은 DI 컨테이너의 도움(자동 프록시 생성 방식) 없이 AOP를 적용할 수 있어서
        - 스프링같은 컨테이너가 사용되지 않는 환경에서도 손쉽게 AOP를 적용할 수 있음
    - 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능
- 물론 대부분의 부가 기능은 프록시 방식을 통해서 해결하는걸로 충분하지만, 섬세한 작업에선 바이트코드 조작이 필요하다는 뜻

### AOP 용어
- 타깃
    - 부가 기능을 부여할 대상
    - 핵심 기능이 담긴 클래스일 수도, 다른 부가 기능을 제공하는 프록시 오브젝트가 될 수도 있음
- 어드바이스
    - 타깃에게 제공할 부가 기능을 담은 모듈
- 조인포인트
    - 어드바이스가 적용될 수 있는 위치
- 포인트컷
    - 어드바이스를 적용할 조인포인트를 선별하는 작업, 또는 그 기능을 정의한 모듈
- 프록시
    - 클라이언트와 타깃 사이에 <sub>투명한 장벽처럼</sub> 존재하며, 부가 기능을 제공하는 오브젝트
    - DI를 통해 타깃 대신 클라이언트에게 주입되며, 클라이언트의 메서드 호출을 대신 받아 타깃에게 위임해주고 그 과정에서 부가 기능을 부여함
    - 스프링은 프록시를 이용해 AOP를 지원함
- 어드바이저
    - (포인트컷 + 어드바이스) 기능을 가진 오브젝트
    - 스프링 AOP에서만 사용되는 용어
- 애스펙트
    - AOP의 기본 모듈
    - 스프링의 어드바이저는 아주 단순한 애스펙트라 할 수 있다

### 트랜잭션 속성
#### 트랜잭션 전파<sub>transaction propagation</sub>    
트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있으면 혹은 없다면 어떻게 동작할 것인지 결정하는 속성.     
- PROPAGATION_REQUIRED
    - 가장 많이 사용되는 트랜잭션 전파 속성
    - 진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 이에 참여한다
- PROPAGATION_REQUIRES_NEW
    - 항상 새로운 트랜잭션을 시작
    - 만약 앞서서 시작된 트랜잭션이 있다면, 이와 상관없이 새로운 트랜잭션을 만들어 독자적으로 동작
    - 독립적인 트랜잭션이 보장돼야 하는 코드에 사용
- PROPAGATION_NOT_SUPPORTED
    - 트랜잭션 없이 동작하도록 설정
    - 진행 중인 트랜잭션이 있어도 이를 무시

#### 격리 수준<sub>isolation level</sub>     
격리 수준은 기본적으로 DB에 설정되어 있지만, JDBC 드라이버나 DataSource 등에서 재설정할 수도 있고, 필요에 따라 트랜잭션 단위로도 격리 수준을 조정할 수 있다.      
- `ISOLATION_DEFAULT`
    - DataSource에 설정돼있는 디폴트 격리 수준을 그대로 따른다는 뜻

#### 제한 시간<sub>timeout</sub>    
트랜잭션을 수행하는 시간.    
이 설정은 트랜잭션을 직접 시작할 수 있는 `PROPAGATION_REQUIRED`나 `PROPAGATION_REQUIRES_NEW`와 함께 사용해야 의미가 있다.     

#### 읽기 전용<sub>read only</sub>    
읽기 전용으로 설정해두면, 트랜잭션 내에서 데이터를 조작하는 시도를 막을 수 있다. 또한 데이터 엑세스 기술에 따라 성능이 향상될 수도 있다.     

> - `timeout`이나 `readOnly`는 트랜잭션이 처음 시작될 때가 아니라면 적용되지 않음

### **프록시 방식 AOP는 같은 타깃 오브젝트 내의 메서드를 호출할 땐 적용되지 않는다**
- 프록시 방식의 AOP에서는 프록시를 통한 부가 기능 적용이, 클라이언트로부터의 호출일 때만 가능하다
- 타깃 오브젝트가 자기 자신 내에 선언된 메서드를 호출할 땐 프록시를 통한 부가 기능 적용이 일어나지 않는다
  
### `@Transactional`
- 트랜잭션 애너테이션
- 타깃에 붙여 사용
    - 메서드, 클래스, 인터페이스에 사용 가능  
- 4단계의 대체<sub>failback</sub> 정책이 존재
    - 메서드 속성 확인 시 `타깃 메서드 > 타깃 클래스 > 선언 메서드 > 선언 타입(클래스, 인터페이스)`순서로, `@Transactional`가 붙어있는지 확인하고, 가장 먼저 발견되는 속성정보를 사용한다
    - 책에서는 타깃 클래스와 타깃 메서드에 적용하는걸 권고

### 선언적 트랜잭션
- 선언적 트랜잭션<sub>declarative transaction</sub>
    - AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고, 속성을 지정할 수 있게 하는 방법
    - 스프링은 평범한 자바 클래스로 만든 오브젝트에도 선언적 트랜잭션을 적용할 수 있다. 트랜잭션 추상화를 함께 제공하기 때문에 특정 트랜잭션 기술이나 환경에 종속되지도 않음
- 프로그램에 의한 트랜잭션 <sub>programmatic transaction</sub>
    - `TransactionTemplate`이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에서 사용하는 방법

> 스프링은 위 2가지 방법을 모두 지원하지만 책에서는 선언적 트랜잭션을 사용하는 것을 권장   

### 트랜잭션 동기화 기술
- 트랜잭션 정보를 저장소에 보관해뒀다가 DAO에서 공유해서 사용 가능     

### 롤백 테스트
- 테스트 내 모든 DB 작업을 하나의 트랜잭션 안에서 동작하게 하고, 테스트가 끝나면 무조건 롤백해버리는 테스트
- 테스트에서 트랜잭션을 제어할 수 있기 때문에 얻을 수 있는 가장 유익한 기능이다 

<br/>
<br/>

---

<br/>
<br/>

# 7장: 스프링 핵심 기술의 응용

### 리소스 로더
- 스프링은 문자열로 정의된 리소스를 실제 `Resource`타입 오브젝트로 변환해주는 `ResourceLoader`를 제공한다
    - `Resource`는 문자열 안에 리소스의 종류와 리소스의 위치를 함께 표현하게 해준다. 그리고 이렇게 문자열로 정의된 리소스는 `ResourceLoader`를 통해 실제 `Resource` 타입 오브젝트로 변환된다

### 인터페이스 분리 원칙<sub>interface segregation principle</sub>
> **클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하자**
- 목적과 관심이 각기 다른 클라이언트가 있다면, 인터페이스를 통해 이를 적절하게 분리해줄 필요가 있다. 이를 객체지향 설계 원칙에선 ISP라고 한다

### `@ContextConfiguration`
- DI 정보를 어디서 가져올 지 지정할 때 사용
    - 애플리케이션 컨텍스트의 설정 파일 위치 지정
- `classes` 속성에는 '적용할 설정 클래스'들을 나열해주면 된다.
    - 클래스는 하나 이상 지정할 수 있다

### `@Import`
- 자바 클래스로 된 설정 정보를 가져올 때 사용

### `@Bean`
- `@Bean` 메서드는 bean 인스턴스 생성과 프로퍼티를 설정한다
- `@Bean`으로 인스턴스 생성 시, 해당 클래스의 생성자가 public이어야 접근 가능하다
    > - XML로 `<bean>` 이렇게 해서 bean을 생성해줄 땐 굳이 public이 아니어도 되었다. 왜냐면 내부적으로 리플렉션 API를 이용하기 떄문. 그래서 private으로 선언되어 접근이 제한됐어도, bean 클래스를 생성할 수 있었다

### `@Autowired`
- 이 애너테이션은, 이 애너테이션이 붙은 필드의 타입과 동일한 타입의 bean이 있으면 해당 bean을 **필드**나 **수정자 메서드**에 <sub>자동으로</sub> 주입해준다
- 만약 필드가 private으로 선언되어 있어도, 스프링은 bean을 주입해줄 수 있다
    - 스프링은 리플렉션 api를 이용해 제약조건을 우회해서 값을 넣어줌

### `@Resource`
- 이 애너테이션은 `@Autowired`와 유사하게 필드에 bean을 주입받을 때 사용한다
    - 둘의 차이점은 `@Resource`는 필드 **이름**을 기준으로 bean을 찾는다

### `@Component`
- bean 스캐너를 통해 자동으로 bean 등록 대상이 된다
- `@Component`를 메타 애너테이션으로 사용할 수도 있다
- `@Component`가 달린 클래스를 bean으로 등록하게 해주려면, bean 스캔 기능을 사용하겠다는 애너테이션 정의가 필요하다
    - 특정 패키지 아래서만 찾도록, 기준이 되는 패키지를 지정해주고자 할 때 `@ComponentScan`이 사용된다

### `@ComponentScan`
- `@ComponentScan`의 속성 중 `basePackages`는, `@Component`가 붙은 클래스를 스캔할 기준 패키지를 지정할 때 사용한다
    - 기준 패키지는 여러 개를 넣을 수 있다
    - 지정한 패키지 하위, 모든 서브 패키지를 검색해준다

### `@Repository`
- 스프링은 DAO 기능을 제공하는 클래스에는 `@Repository`를 붙이도록 권장함
- `@Repository`는 `@Component`를 메타 애너테이션으로 갖고 있다             

### `@Service`
- 비즈니스 로직을 담고 있는 서비스 계층의 bean을 구분하기 위해 사용됨
- `@Service`는 `@Component`를 메타 애너테이션으로 갖고 있다               

### `@Profile`
- 클래스 레벨에 부여하고, 프로파일 이름을 넣어준다
- 프로파일이 지정되어 있지 않은 bean 설정은 default 프로파일로 취급받아, 항상 적용된다
- `@Profile`이 붙은 설정 클래스는 현재 컨테이너의 활성<sub>active</sub>프로파일 목록에 자신의 프로파일 이름이 들어 있지 않으면 무시된다

### `@PropertySource`
- 특정 파일에서 프로퍼티 값을 가져와야 할 때, 프로퍼티 소스를 등록해줘야 하는데 이때 `@PropertySource`가 사용된다

### `@Value`
- `@Value`는 값을 주입받을 때 사용한다
- `@Value`의 사용 방법은 여러 가지가 있는데, 그중 하나는 '프로퍼티 소스로부터 값을 주입받을 수 있게 치환자<sub>placeholder</sub>를 이용'하는 방법이다
    - '컨테이너가 제공하는 프로퍼티 값'을 주입받을 필드를 선언하고 `@Value`를 붙여주면 된다

<br/>
<br/>

---

<br/>
<br/>

# 8장: 스프링이란 무엇인가
스프링 정의
- 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크

> 스프링은 결국 '객체지향'이라는 자바 언어가 가진 강력한 도구를 극대화하해서 사용할 수 있도록 거들기만 할 뿐. 객체지향을 잘 활용해 복잡한 문제를 해결해, 요구사항에 유연하게 대응하는 뛰어난 애플리케이션을 만드는 것은 개발자의 역량에 달렸다.

### POJO<sub>plain old java object</sub> 프로그래밍
- POJO의 조건
    - 특정 규약<sub>contract</sub>에 종속되지 않는다
        - POJO는 자바 언어와 꼭 필요한 API 외에는 종속되지 않아야 한다    
    - 특정 환경에 종속되지 않는다
        - 특정 환경에 종속적이어야만 동작 가능한 오브젝트는 POJO가 아니다    
    - 객체지향적 자바 언어의 기본에 충실하게 만들어져야 한다
        - 자바 언어 문법을 사용했다고 해서, 자동으로 객체지향 프로그래밍/설계가 적용됐다고 할 수 없다

### 스프링 주요 기술
- 스프링에서 POJO 프로그래밍을 손쉽게 할 수 있도록 지원하는 기능 기술<sub>enabling technology</sub>
    - IoC/DI. AOP, PSA

<br/>
<br/>

---

<br/>
<br/>

# 9장: 스프링 프로젝트 시작하기
